<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Picker Wheel</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        h1 {
            color: #1a73e8; /* Google Blue */
            margin-bottom: 25px;
        }
        h2 {
            color: #333;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #5f6368;
        }

        .input-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #dadce0;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 16px;
            background-color: #fff;
        }
        .input-group select:focus {
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
            outline: none;
        }

        button {
            background-color: #1a73e8;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            margin-top: 10px;
        }

        button:hover {
            background-color: #1765c7;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button:disabled {
            background-color: #e0e0e0;
            color: #9e9e9e;
            cursor: not-allowed;
            box-shadow: none;
        }

        #wheel-container {
            position: relative;
            width: 320px; /* Slightly larger for border */
            height: 320px;
            margin: 25px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #wheel {
            width: 300px; /* Canvas size */
            height: 300px;
            border-radius: 50%;
            /* border: 5px solid #5f6368; */ /* Canvas draws its own border if needed */
            position: relative;
            overflow: hidden;
            transition: transform 5s cubic-bezier(0.33, 1, 0.68, 1); /* Smoother ease-out spin */
            background-color: #f8f9fa; /* Fallback */
        }

        #wheel canvas {
            display: block; /* Removes extra space below canvas */
        }

        #pointer { /* Pointer at 3 o'clock */
            width: 0;
            height: 0;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            border-left: 30px solid #d93025; /* Red pointer */
            position: absolute;
            right: -5px; /* Positioned to the right, slightly overlapping wheel's edge */
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        #result {
            margin-top: 25px;
            font-size: 2.2em; /* Larger font for chosen name */
            font-weight: bold;
            color: #1a73e8;
            padding: 15px;
            background-color: #e8f0fe; /* Light blue background */
            border-radius: 8px;
            min-height: 50px; /* Ensure space even when text is '?' */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.95em;
        }
        .error-message {
            color: #d93025; /* Material Red */
            background-color: #fce8e6;
            border: 1px solid #d93025;
        }
        .info-message {
            color: #1765c7; /* Darker Blue */
            background-color: #e8f0fe;
            border: 1px solid #1a73e8;
        }
        .subtle-message {
            font-size: 0.9em;
            color: #5f6368;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Student Picker Wheel</h1>

        <p id="repoInfo" class="subtle-message">Attempting to load classes...</p>
        <p id="apiStatus" class="message" style="display:none;"></p>

        <div class="input-group" id="classSelectionGroup" style="display:none;">
            <label for="classSelect">Select a Class:</label>
            <select id="classSelect"></select>
        </div>

        <div id="wheel-section" style="display:none;">
            <h2>Spin the Wheel!</h2>
            <div id="wheel-container">
                <div id="pointer"></div>
                <div id="wheel">
                    <canvas id="wheelCanvas"></canvas>
                </div>
            </div>
            <button id="spinBtn" disabled>Spin</button>
            <div id="result">?</div>
        </div>
         <p id="studentsLeft" class="message info-message" style="display:none;"></p>
    </div>

    <script>
        const classSelect = document.getElementById('classSelect');
        const classSelectionGroup = document.getElementById('classSelectionGroup');
        const wheelSection = document.getElementById('wheel-section');
        const spinBtn = document.getElementById('spinBtn');
        const wheel = document.getElementById('wheel');
        const wheelCanvas = document.getElementById('wheelCanvas');
        const resultDisplay = document.getElementById('result');
        const apiStatus = document.getElementById('apiStatus');
        const studentsLeftDisplay = document.getElementById('studentsLeft');
        const repoInfoDisplay = document.getElementById('repoInfo');

        // --- GitHub Configuration ---
        // Option 1: Automatic Detection (primarily for GitHub Pages)
        let GITHUB_USER = '';
        let GITHUB_REPO = '';
        const FOLDER_PATH = 'klassen'; // Your folder name

        // Option 2: Manual Override (Uncomment and set these if auto-detection fails or for local use)
        // const MANUAL_GITHUB_USER = "your-username";
        // const MANUAL_GITHUB_REPO = "your-repo-name";

        const GITHUB_API_BASE = 'https://api.github.com/repos';

        let currentStudents = [];
        let availableStudents = [];
        let classFilesData = []; // To store {name, download_url}

        function setApiStatus(message, type = 'info') {
            apiStatus.textContent = message;
            apiStatus.className = `message ${type}-message`;
            apiStatus.style.display = 'block';
        }

        function setRepoInfo(message) {
            repoInfoDisplay.textContent = message;
            repoInfoDisplay.style.display = 'block';
        }

        async function autoDetectRepoAndFetchClasses() {
            // Check for manual override first
            if (typeof MANUAL_GITHUB_USER !== 'undefined' && MANUAL_GITHUB_USER &&
                typeof MANUAL_GITHUB_REPO !== 'undefined' && MANUAL_GITHUB_REPO) {
                GITHUB_USER = MANUAL_GITHUB_USER;
                GITHUB_REPO = MANUAL_GITHUB_REPO;
                setRepoInfo(`Using manual config: ${GITHUB_USER}/${GITHUB_REPO}. Fetching classes...`);
                await fetchClasses();
                return;
            }

            const hostname = window.location.hostname;
            const pathname = window.location.pathname;

            if (hostname.endsWith('github.io')) {
                const parts = hostname.split('.');
                GITHUB_USER = parts[0];
                // For repositories like <user>.github.io/<repo>/
                const pathSegments = pathname.split('/').filter(segment => segment.length > 0);
                if (pathSegments.length > 0 && pathSegments[0] !== FOLDER_PATH && !pathSegments[0].endsWith('.html')) {
                    GITHUB_REPO = pathSegments[0];
                } else {
                    // For user/org pages like <user>.github.io directly
                    GITHUB_REPO = hostname;
                }
                setRepoInfo(`Detected: ${GITHUB_USER}/${GITHUB_REPO}. Fetching classes from '${FOLDER_PATH}'...`);
                await fetchClasses();
            } else if (window.location.protocol === 'file:') {
                 setRepoInfo('Running locally. Automatic repo detection disabled.');
                 setApiStatus('Please configure GITHUB_USER and GITHUB_REPO manually in the script for local use, or deploy to GitHub Pages.', 'error');
                 // You might want to enable manual input fields here as a fallback
            } else {
                setRepoInfo('Could not auto-detect GitHub repository.');
                setApiStatus('Automatic repository detection failed. Please ensure this page is hosted on GitHub Pages or configure manually.', 'error');
            }
        }


        async function fetchClasses() {
            if (!GITHUB_USER || !GITHUB_REPO) {
                setApiStatus('GitHub user or repository not set.', 'error');
                return;
            }

            setApiStatus('Fetching classes...', 'info');
            classSelectionGroup.style.display = 'none';
            wheelSection.style.display = 'none';

            try {
                const response = await fetch(`${GITHUB_API_BASE}/${GITHUB_USER}/${GITHUB_REPO}/contents/${FOLDER_PATH}`);
                if (!response.ok) {
                    let errorMsg = `Error fetching classes: ${response.statusText} (Status: ${response.status}).`;
                    if (response.status === 404) {
                        errorMsg = `Folder '${FOLDER_PATH}' not found in ${GITHUB_USER}/${GITHUB_REPO}, or repository is private/incorrect.`;
                    } else if (response.status === 403) {
                         errorMsg = 'API rate limit exceeded or access forbidden. Wait a bit or check repo permissions.';
                    }
                    throw new Error(errorMsg);
                }
                const data = await response.json();
                
                classFilesData = data
                    .filter(file => file.type === 'file' && file.name.endsWith('.txt'))
                    .map(file => ({ name: file.name.replace('.txt', ''), download_url: file.download_url }));

                if (classFilesData.length === 0) {
                    setApiStatus(`No .txt files found in the '${FOLDER_PATH}' folder of ${GITHUB_USER}/${GITHUB_REPO}.`, 'error');
                    return;
                }

                populateClassSelector();
                classSelectionGroup.style.display = 'block';
                setApiStatus('Classes loaded. Please select a class.', 'info');
                repoInfoDisplay.style.display = 'none'; // Hide repo info once classes are loaded

            } catch (error) {
                console.error('Error fetching classes:', error);
                setApiStatus(`Error: ${error.message}`, 'error');
            }
        }

        function populateClassSelector() {
            classSelect.innerHTML = '<option value="">-- Select a Class --</option>';
            classFilesData.forEach(file => {
                const option = document.createElement('option');
                option.value = file.download_url;
                option.textContent = file.name;
                classSelect.appendChild(option);
            });
            wheelSection.style.display = 'none';
        }

        classSelect.addEventListener('change', async (event) => {
            const fileUrl = event.target.value;
            resultDisplay.textContent = '?'; // Reset result display
            studentsLeftDisplay.style.display = 'none';
            wheel.style.transform = 'rotate(0deg)'; // Reset wheel rotation visually

            if (!fileUrl) {
                wheelSection.style.display = 'none';
                currentStudents = [];
                availableStudents = [];
                spinBtn.disabled = true;
                drawWheel([]);
                return;
            }

            setApiStatus('Loading student list...', 'info');
            spinBtn.disabled = true;

            try {
                const response = await fetch(fileUrl);
                if (!response.ok) {
                    throw new Error(`Workspaceing student list failed: ${response.statusText}`);
                }
                const textContent = await response.text();
                currentStudents = textContent.split('\n').map(name => name.trim()).filter(name => name.length > 0);
                availableStudents = [...currentStudents];

                if (availableStudents.length === 0) {
                    setApiStatus('No students found in this class file, or file is empty/misformatted.', 'error');
                    wheelSection.style.display = 'block';
                    spinBtn.disabled = true;
                    drawWheel([]);
                } else {
                    drawWheel(availableStudents);
                    wheelSection.style.display = 'block';
                    spinBtn.disabled = false;
                    updateStudentsLeftDisplay();
                    setApiStatus('Student list loaded. Ready to spin!', 'info');
                }

            } catch (error) {
                console.error('Error fetching student list:', error);
                setApiStatus(`Error loading students: ${error.message}`, 'error');
                wheelSection.style.display = 'block'; // Show section to display error within it
                spinBtn.disabled = true;
                drawWheel([]); // Draw empty wheel on error
            }
        });

        let isSpinning = false;
        let currentWheelRotation = 0; // Tracks the actual rotation for CSS

        function drawWheel(names) {
            const ctx = wheelCanvas.getContext('2d');
            const numSegments = names.length;
            const canvasSize = 300;
            wheelCanvas.width = canvasSize;
            wheelCanvas.height = canvasSize;

            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const radius = canvasSize / 2 - 5; // Leave a small margin for border/look

            ctx.clearRect(0, 0, canvasSize, canvasSize);

            if (numSegments === 0) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                ctx.strokeStyle = '#ccc';
                ctx.stroke();
                ctx.fillStyle = '#555';
                ctx.font = 'bold 18px "Segoe UI", Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('No Students', centerX, centerY);
                return;
            }

            const anglePerSegment = (2 * Math.PI) / numSegments;
            // Vibrant and distinct colors
            const colors = ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#7E57C2", "#5C6BC0", "#26A69A"];

            ctx.font = 'bold 13px "Segoe UI", Arial'; // Adjusted font size slightly

            names.forEach((name, i) => {
                const startAngle = i * anglePerSegment;
                const endAngle = (i + 1) * anglePerSegment;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                ctx.strokeStyle = '#fff'; // White lines between segments
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw text
                ctx.save();
                ctx.translate(centerX, centerY);
                // Rotate to the middle of the segment
                // The 0 angle is at 3 o'clock. Text should be written along this line.
                ctx.rotate(startAngle + anglePerSegment / 2);
                
                ctx.textAlign = 'right'; // Text flows away from center
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#ffffff'; // White text for better contrast on colored segments
                
                const displayName = name.length > 15 ? name.substring(0, 13) + '...' : name;
                ctx.fillText(displayName, radius - 10, 0); // Draw text near the edge
                ctx.restore();
            });
        }

        spinBtn.addEventListener('click', () => {
            if (isSpinning || availableStudents.length === 0) return;

            isSpinning = true;
            spinBtn.disabled = true;
            resultDisplay.textContent = 'Spinning...';

            const numSegments = availableStudents.length;
            const randomIndex = Math.floor(Math.random() * numSegments);
            const selectedName = availableStudents[randomIndex];
            
            // Angle for each segment in degrees
            const anglePerSegmentDegrees = 360 / numSegments;
            // The middle of the target segment (degrees). Segment 0 starts at 3 o'clock.
            // Angle is measured clockwise from 3 o'clock.
            const targetSegmentMiddleAngleDegrees = (randomIndex + 0.5) * anglePerSegmentDegrees;
            
            // We want this targetSegmentMiddleAngleDegrees to align with the 0-degree pointer (3 o'clock).
            // So, the wheel needs to rotate by -(targetSegmentMiddleAngleDegrees).
            // Add multiple full rotations for visual effect + a small random offset for variability.
            const randomExtraRotations = 3 + Math.floor(Math.random() * 3); // 3 to 5 full spins
            // Subtract target angle to bring it to 0. Add a small random jitter.
            const targetRotation = (randomExtraRotations * 360) - targetSegmentMiddleAngleDegrees + (Math.random() * anglePerSegmentDegrees * 0.4 - anglePerSegmentDegrees * 0.2);


            currentWheelRotation += targetRotation; // Accumulate rotation
            wheel.style.transform = `rotate(${currentWheelRotation}deg)`;

            setTimeout(() => {
                isSpinning = false;
                if (availableStudents.length > 0) { // Check again
                    resultDisplay.textContent = `${selectedName}`; // Just the name, bigger
                    
                    availableStudents.splice(randomIndex, 1);
                    updateStudentsLeftDisplay();

                    if (availableStudents.length > 0) {
                        // No need to redraw the wheel if names aren't changing visually,
                        // but if you want to remove the segment visually, you'd redraw.
                        // For simplicity, we are not redrawing segments, only tracking internally.
                        // If you want segments to disappear, call drawWheel(availableStudents) here.
                        // For now, let's assume the visual segments remain for simplicity,
                        // and the pool of 'availableStudents' is what matters.
                        // To make it visually clear, we SHOULD redraw.
                        drawWheel(availableStudents);
                        spinBtn.disabled = false;
                    } else {
                        drawWheel([]); // Draw empty wheel
                        resultDisplay.textContent = `${selectedName}`; // Show final selected name
                        studentsLeftDisplay.textContent = 'All students have been picked!';
                        studentsLeftDisplay.style.display = 'block';
                        spinBtn.disabled = true;
                    }
                }
            }, 5000); // Match CSS transition duration
        });
        
        function updateStudentsLeftDisplay() {
            if (availableStudents.length > 0) {
                studentsLeftDisplay.textContent = `${availableStudents.length} student(s) remaining.`;
                studentsLeftDisplay.style.display = 'block';
            } else if (currentStudents.length > 0 && availableStudents.length === 0) {
                 studentsLeftDisplay.textContent = 'All students have been picked!';
                 studentsLeftDisplay.style.display = 'block';
            }
            else {
                studentsLeftDisplay.style.display = 'none';
            }
        }

        // --- Initial Load ---
        window.onload = () => {
            drawWheel([]); // Draw an empty wheel initially
            autoDetectRepoAndFetchClasses();
        };
    </script>
</body>
</html>
