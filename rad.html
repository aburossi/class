<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Picker Cylinder</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 650px;
            text-align: center;
        }

        h1 {
            color: #1a73e8; /* Google Blue */
            margin-bottom: 25px;
        }
        h2 {
            color: #333;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #5f6368;
        }

        .input-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #dadce0;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 16px;
            background-color: #fff;
        }
        .input-group select:focus {
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
            outline: none;
        }

        button {
            background-color: #1a73e8;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            margin-top: 10px;
        }

        button:hover {
            background-color: #1765c7;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button:disabled {
            background-color: #e0e0e0;
            color: #9e9e9e;
            cursor: not-allowed;
            box-shadow: none;
        }

        #wheel-container { /* Renamed semantically, but reusing ID for less JS change */
            position: relative;
            width: 320px; /* Width of the cylinder viewport */
            height: 70px; /* Height of the cylinder viewport + some padding */
            margin: 25px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e8f0fe; /* Light background for contrast with pointer */
            border: 1px solid #dadce0;
            border-radius: 4px;
        }

        #wheel { /* This is the viewport for the canvas */
            width: 300px;  /* Canvas width */
            height: 50px; /* Canvas height */
            position: relative;
            overflow: hidden;
            background-color: #f8f9fa;
            /* No border-radius for cylinder, no CSS transform for spinning */
        }

        #wheel canvas {
            display: block;
            /* width and height set in JS */
        }

        #pointer { /* Vertical line pointer */
            width: 3px;
            height: 40px; /* Adjust to be less than canvas viewport height */
            background-color: #d93025; /* Red pointer */
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            border-radius: 1px;
        }

        #result {
            margin-top: 25px;
            font-size: 2.2em;
            font-weight: bold;
            color: #1a73e8;
            padding: 15px;
            background-color: #e8f0fe;
            border-radius: 8px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.95em;
        }
        .error-message {
            color: #d93025;
            background-color: #fce8e6;
            border: 1px solid #d93025;
        }
        .info-message {
            color: #1765c7;
            background-color: #e8f0fe;
            border: 1px solid #1a73e8;
        }
        .subtle-message {
            font-size: 0.9em;
            color: #5f6368;
            margin-top: 5px;
        }
    </style></head>
<body>
    <div class="container">
        <h1>Student Picker Cylinder</h1>

        <p id="repoInfo" class="subtle-message">Attempting to load classes...</p>
        <p id="apiStatus" class="message" style="display:none;"></p>

        <div class="input-group" id="classSelectionGroup" style="display:none;">
            <label for="classSelect">Select a Class:</label>
            <select id="classSelect"></select>
        </div>

        <div id="wheel-section" style="display:none;">
            <h2>Roll the Cylinder!</h2>
            <div id="wheel-container">
                <div id="pointer"></div>
                <div id="wheel"> {/* This is now the viewport for the canvas cylinder */}
                    <canvas id="wheelCanvas"></canvas>
                </div>
            </div>
            <button id="spinBtn" disabled>Roll</button>
            <div id="result">?</div>
        </div>
        <p id="studentsLeft" class="message info-message" style="display:none;"></p>
    </div>

    <script>
        const classSelect = document.getElementById('classSelect');
        const classSelectionGroup = document.getElementById('classSelectionGroup');
        const wheelSection = document.getElementById('wheel-section');
        const spinBtn = document.getElementById('spinBtn');
        // const wheelDiv = document.getElementById('wheel'); // We still have this div as canvas container
        const wheelCanvas = document.getElementById('wheelCanvas');
        const resultDisplay = document.getElementById('result');
        const apiStatus = document.getElementById('apiStatus');
        const studentsLeftDisplay = document.getElementById('studentsLeft');
        const repoInfoDisplay = document.getElementById('repoInfo');

        let GITHUB_USER = '';
        let GITHUB_REPO = '';
        const FOLDER_PATH = 'klassen';

        // const MANUAL_GITHUB_USER = "your-username";
        // const MANUAL_GITHUB_REPO = "your-repo-name";

        const GITHUB_API_BASE = 'https://api.github.com/repos';

        let allStudentsInClass = [];
        let availableStudentsToPick = [];
        let classFilesData = [];

        let isSpinning = false; // Changed from isSpinning
        // === Cylinder Specific Variables ===
        let currentCylinderItems = []; // Items currently displayed on the cylinder
        let currentScrollOffset = 0; // Horizontal scroll position of the cylinder items
        const ITEM_WIDTH = 150; // Apparent width of each item slot on the cylinder
        const CYLINDER_TEXT_COLOR = '#333333';
        const CYLINDER_FONT = 'bold 18px "Segoe UI", Arial';
        // === End Cylinder Specific Variables ===

        function setApiStatus(message, type = 'info') {
            apiStatus.textContent = message;
            apiStatus.className = `message ${type}-message`;
            apiStatus.style.display = 'block';
        }

        function setRepoInfo(message) {
            repoInfoDisplay.textContent = message;
            repoInfoDisplay.style.display = 'block';
        }

        async function autoDetectRepoAndFetchClasses() {
            if (typeof MANUAL_GITHUB_USER !== 'undefined' && MANUAL_GITHUB_USER &&
                typeof MANUAL_GITHUB_REPO !== 'undefined' && MANUAL_GITHUB_REPO) {
                GITHUB_USER = MANUAL_GITHUB_USER;
                GITHUB_REPO = MANUAL_GITHUB_REPO;
                setRepoInfo(`Using manual config: ${GITHUB_USER}/${GITHUB_REPO}.`);
            } else {
                const hostname = window.location.hostname;
                const pathname = window.location.pathname;
                if (hostname.endsWith('github.io')) {
                    const parts = hostname.split('.');
                    GITHUB_USER = parts[0];
                    const pathSegments = pathname.split('/').filter(segment => segment.length > 0 && !segment.endsWith('.html'));
                    if (pathSegments.length > 0 && pathSegments[0].toLowerCase() !== FOLDER_PATH.toLowerCase()) {
                        GITHUB_REPO = pathSegments[0];
                    } else {
                         // If repo is the root of the github.io page, or if the first path segment IS the folder_path
                        // this logic might need adjustment based on actual GH pages deployment structure.
                        // For a URL like user.github.io/repoName/, pathSegments[0] is 'repoName'
                        // For user.github.io/ (where repo is user.github.io), pathSegments is empty.
                        GITHUB_REPO = pathSegments[0] || GITHUB_USER + ".github.io"; // Fallback for root repo
                    }
                    setRepoInfo(`Detected: ${GITHUB_USER}/${GITHUB_REPO}.`);
                } else if (window.location.protocol === 'file:') {
                    setRepoInfo('Running locally. Automatic repo detection may not work.');
                    setApiStatus('For local use, ensure GITHUB_USER and GITHUB_REPO are set manually in the script if issues arise, or deploy to GitHub Pages.', 'info');
                    if (typeof MANUAL_GITHUB_USER !== 'undefined' && MANUAL_GITHUB_USER) GITHUB_USER = MANUAL_GITHUB_USER;
                    if (typeof MANUAL_GITHUB_REPO !== 'undefined' && MANUAL_GITHUB_REPO) GITHUB_REPO = MANUAL_GITHUB_REPO;
                } else {
                    setRepoInfo('Could not auto-detect GitHub repository details.');
                    setApiStatus('Automatic repository detection failed. Please ensure this page is hosted on GitHub Pages or configure GITHUB_USER/REPO manually in the script.', 'error');
                    return;
                }
            }

            if (GITHUB_USER && GITHUB_REPO) {
                await fetchClassesList();
            } else {
                setApiStatus('GitHub user and repository not determined. Cannot fetch classes.', 'error');
            }
        }

        async function fetchClassesList() {
            setApiStatus(`Workspaceing classes from '${FOLDER_PATH}'...`, 'info');
            classSelectionGroup.style.display = 'none';
            wheelSection.style.display = 'none';

            try {
                const response = await fetch(`${GITHUB_API_BASE}/${GITHUB_USER}/${GITHUB_REPO}/contents/${FOLDER_PATH}`);
                if (!response.ok) {
                    let errorMsg = `Error fetching classes list: ${response.statusText} (Status: ${response.status}).`;
                    if (response.status === 404) errorMsg = `Folder '${FOLDER_PATH}' not found in ${GITHUB_USER}/${GITHUB_REPO}, or repository is private/incorrect. Check path and permissions.`;
                    else if (response.status === 403) errorMsg = 'API rate limit exceeded or access forbidden. Check repo permissions/API limits.';
                    throw new Error(errorMsg);
                }
                const data = await response.json();

                classFilesData = data
                    .filter(file => file.type === 'file' && file.name.endsWith('.txt'))
                    .map(file => ({ name: file.name.replace('.txt', ''), download_url: file.download_url }));

                if (classFilesData.length === 0) {
                    setApiStatus(`No .txt files found in '${FOLDER_PATH}' of ${GITHUB_USER}/${GITHUB_REPO}.`, 'error');
                    return;
                }

                populateClassSelector();
                classSelectionGroup.style.display = 'block';
                setApiStatus('Classes list loaded. Please select a class.', 'info');
                repoInfoDisplay.style.display = 'none';

            } catch (error) {
                console.error('Error fetching classes list:', error);
                setApiStatus(`${error.message}`, 'error');
            }
        }

        function populateClassSelector() {
            classSelect.innerHTML = '<option value="">-- Select a Class --</option>';
            classFilesData.forEach(file => {
                const option = document.createElement('option');
                option.value = file.download_url;
                option.textContent = file.name; // This is the class name (filename without .txt)
                classSelect.appendChild(option);
            });
            wheelSection.style.display = 'none';
        }

        classSelect.addEventListener('change', async (event) => {
            const fileUrl = event.target.value;
            const selectedOptionText = event.target.options[event.target.selectedIndex].text;

            resultDisplay.textContent = '?';
            studentsLeftDisplay.style.display = 'none';
            // No CSS transform reset needed for wheel div

            if (!fileUrl) {
                wheelSection.style.display = 'none';
                allStudentsInClass = [];
                availableStudentsToPick = [];
                spinBtn.disabled = true;
                currentCylinderItems = ["Select a Class"];
                currentScrollOffset = calculateTargetScrollOffset(0, currentCylinderItems); // Center "Select a Class"
                drawCylinder();
                return;
            }

            setApiStatus('Loading student list...', 'info');
            spinBtn.disabled = true;
            wheelSection.style.display = 'block'; // Show section early
            currentCylinderItems = [selectedOptionText]; // Display class name first
            currentScrollOffset = calculateTargetScrollOffset(0, currentCylinderItems);
            drawCylinder();

            try {
                const response = await fetch(fileUrl);
                if (!response.ok) throw new Error(`Workspaceing student list failed: ${response.statusText}`);

                const textContent = await response.text();
                allStudentsInClass = textContent.split('\n').map(name => name.trim()).filter(name => name.length > 0);
                availableStudentsToPick = [...allStudentsInClass];

                if (allStudentsInClass.length === 0) {
                    setApiStatus('No students found in this class file, or file is empty/misformatted.', 'error');
                    currentCylinderItems = ["No Students in Class"];
                    spinBtn.disabled = true;
                } else {
                    currentCylinderItems = [...allStudentsInClass]; // Now populate with students
                    spinBtn.disabled = false;
                    setApiStatus('Student list loaded. Ready to roll!', 'info');
                }
                currentScrollOffset = calculateTargetScrollOffset(0, currentCylinderItems); // Center first student or "No Students"
                drawCylinder();
                updateStudentsLeftDisplay();

            } catch (error) {
                console.error('Error loading student list:', error);
                setApiStatus(`Error loading students: ${error.message}`, 'error');
                currentCylinderItems = ["Error Loading List"];
                currentScrollOffset = calculateTargetScrollOffset(0, currentCylinderItems);
                drawCylinder();
                spinBtn.disabled = true;
            }
        });

        function calculateTargetScrollOffset(targetIndex, itemsArray = currentCylinderItems) {
            if (!itemsArray || itemsArray.length === 0) return 0;
            const targetItemVirtualStripX = (targetIndex * ITEM_WIDTH) + (ITEM_WIDTH / 2);
            return targetItemVirtualStripX - (wheelCanvas.width / 2);
        }

        function drawCylinder() {
            const ctx = wheelCanvas.getContext('2d');
            const canvasWidth = wheelCanvas.width;
            const canvasHeight = wheelCanvas.height;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = CYLINDER_FONT;

            if (!currentCylinderItems || currentCylinderItems.length === 0) {
                ctx.fillStyle = '#888'; // Different color for placeholder
                ctx.fillText('No Items Loaded', canvasWidth / 2, canvasHeight / 2);
                return;
            }

            const numDisplayItems = currentCylinderItems.length;

            // Loop through a virtual strip of items to create a seamless rolling effect
            // Draw enough items to cover the canvas and allow for smooth looping
            const itemsToConsider = numDisplayItems * 3; // Arbitrary multiplier for looping
            const startIndex = Math.floor(currentScrollOffset / ITEM_WIDTH) - Math.ceil(canvasWidth / ITEM_WIDTH) - numDisplayItems;
            const endIndex = Math.ceil((currentScrollOffset + canvasWidth) / ITEM_WIDTH) + numDisplayItems;


            for (let i = startIndex; i < endIndex; i++) {
                const actualItemIndex = (i % numDisplayItems + numDisplayItems) % numDisplayItems; // Handles negative i correctly
                const item = currentCylinderItems[actualItemIndex];

                // Calculate the X position for the center of the item on the *virtual infinite strip*
                const itemCenterOnStripX = i * ITEM_WIDTH + ITEM_WIDTH / 2;

                // Calculate where this item's center should be drawn on the canvas
                const drawOnCanvasX = itemCenterOnStripX - currentScrollOffset;

                // Only draw if it's potentially visible
                if (drawOnCanvasX + ITEM_WIDTH / 2 > 0 && drawOnCanvasX - ITEM_WIDTH / 2 < canvasWidth) {
                    ctx.fillStyle = CYLINDER_TEXT_COLOR;
                    const displayName = item.length > 18 ? item.substring(0, 16) + '...' : item; // Adjust truncation
                    ctx.fillText(displayName, drawOnCanvasX, canvasHeight / 2);
                }
            }
        }


        spinBtn.addEventListener('click', () => {
            if (isSpinning || availableStudentsToPick.length === 0) return;

            isSpinning = true;
            spinBtn.disabled = true;
            resultDisplay.textContent = 'Rolling...';

            // Ensure the cylinder is showing all students from the class for the spin
            if (currentCylinderItems.length !== allStudentsInClass.length || currentCylinderItems[0] !== allStudentsInClass[0]) {
                 //This check might be too strict if class name was an item
                currentCylinderItems = [...allStudentsInClass];
            }


            const winnerName = availableStudentsToPick[Math.floor(Math.random() * availableStudentsToPick.length)];
            const visualIndexOfWinner = allStudentsInClass.indexOf(winnerName);
            const numTotalItems = allStudentsInClass.length;

            if (numTotalItems === 0) { // Should not happen if button is enabled
                isSpinning = false;
                spinBtn.disabled = true;
                return;
            }

            // Calculate the target X position on the virtual strip for the winner's center
            let targetVirtualStripX = (visualIndexOfWinner * ITEM_WIDTH) + (ITEM_WIDTH / 2);

            // Add several full rolls for visual effect
            const randomExtraRolls = 3 + Math.floor(Math.random() * 4);
            targetVirtualStripX += randomExtraRolls * numTotalItems * ITEM_WIDTH;

            // Calculate the final scrollOffset needed to bring targetVirtualStripX to the center of the canvas
            let finalScrollOffset = targetVirtualStripX - (wheelCanvas.width / 2);
            
            // Add a slight random variation to the stopping point within the item's width
            finalScrollOffset += (Math.random() * ITEM_WIDTH * 0.3) - (ITEM_WIDTH * 0.15);


            const startScrollOffset = currentScrollOffset;
            const animationDuration = 5000; // ms
            let startTime = null;

            function animateRoll(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);

                // Ease-out cubic function for smooth deceleration
                const easedProgress = 1 - Math.pow(1 - progress, 4); // Cubic is pow 3, Quartic is pow 4

                currentScrollOffset = startScrollOffset + (finalScrollOffset - startScrollOffset) * easedProgress;
                drawCylinder();

                if (progress < 1) {
                    requestAnimationFrame(animateRoll);
                } else {
                    currentScrollOffset = finalScrollOffset; // Ensure exact landing
                    drawCylinder(); // Final draw at the exact position

                    isSpinning = false;
                    resultDisplay.textContent = `${winnerName}`;

                    const winnerIdxInAvailable = availableStudentsToPick.indexOf(winnerName);
                    if (winnerIdxInAvailable > -1) {
                        availableStudentsToPick.splice(winnerIdxInAvailable, 1);
                    }
                    updateStudentsLeftDisplay();

                    if (availableStudentsToPick.length > 0) {
                        spinBtn.disabled = false;
                    } else {
                        studentsLeftDisplay.textContent = 'All students have been picked!';
                        studentsLeftDisplay.style.display = 'block';
                        spinBtn.disabled = true;
                        // Optionally display a message on the cylinder
                        setTimeout(() => { // Delay slightly so user sees the winner
                           currentCylinderItems = [`All ${allStudentsInClass.length} picked!`];
                           currentScrollOffset = calculateTargetScrollOffset(0, currentCylinderItems);
                           drawCylinder();
                        }, 1000);
                    }
                }
            }
            requestAnimationFrame(animateRoll);
        });

        function updateStudentsLeftDisplay() {
            if (availableStudentsToPick.length > 0 && allStudentsInClass.length > 0) {
                studentsLeftDisplay.textContent = `${availableStudentsToPick.length} student(s) remaining to be picked.`;
                studentsLeftDisplay.style.display = 'block';
            } else if (allStudentsInClass.length > 0 && availableStudentsToPick.length === 0) {
                studentsLeftDisplay.textContent = 'All students have been picked!';
                studentsLeftDisplay.style.display = 'block';
            } else {
                studentsLeftDisplay.style.display = 'none';
            }
        }

        window.onload = () => {
            wheelCanvas.width = 300; // Match #wheel div width from CSS
            wheelCanvas.height = 50; // Match #wheel div height from CSS

            currentCylinderItems = ["Select a Class"];
            currentScrollOffset = calculateTargetScrollOffset(0, currentCylinderItems);
            drawCylinder();
            autoDetectRepoAndFetchClasses();
        };
    </script>
</body>
</html>
